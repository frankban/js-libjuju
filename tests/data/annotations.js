/**
  Juju Annotations version 2.
  This API facade is available on model connections.

  NOTE: this file has been generated by the generate command in js-libjuju
  on Wed 2042/01/01 16:42:47 UTC. Do not manually edit this file.
*/

'use strict';


/**
  Annotations!
*/
class AnnotationsV2 {

  constructor(transport, info) {
    this._transport = transport;
    this._info = info;
    this.version = 2;
  }

  /**
    Get returns annotations for given entities. If annotations cannot be
    retrieved for a given entity, an error is returned. Each entity is
    treated independently and, hence, will fail or succeed independently.

    @param {Object} args Arguments to be provided to Juju, as an object like
      the following:
        {
          entities: []{
            tag: string
          }
        }
    @param {Function} callback Called when the response from Juju is available,
      the callback receives an error and the result. If there are no errors,
      the result is provided as an object like the following:
        {
          results: []{
            entity: string,
            annotations: map[string]string,
            error: {
              error: {
                message: string,
                code: string
              }
            }
          }
        }
  */
  get(args, callback) {
    // Prepare request parameters.
    let params;
    // github.com/juju/juju/apiserver/params#Entities
    params = {};
    args = args || {};
    params['entities'] = [];
    args.entities = args.entities || [];
    for (let i = 0; i < args.entities.length; i++) {
      // github.com/juju/juju/apiserver/params#Entity
      params['entities'][i] = {};
      args.entities[i] = args.entities[i] || {};
      params['entities'][i]['tag'] = args.entities[i].tag;
    }
    // Prepare the request to the Juju API.
    const req = {
      type: 'Annotations',
      request: 'Get',
      version: 2,
      params: params
    };
    // Send the request to the server.
    this._transport.write(req, (err, resp) => {
      if (!callback) {
        return;
      }
      if (err) {
        callback(err, {});
        return;
      }
      // Handle the response.
      let result;
      // github.com/juju/juju/apiserver/params#AnnotationsGetResults
      result = {};
      resp = resp || {};
      result.results = [];
      resp['results'] = resp['results'] || [];
      for (let i = 0; i < resp['results'].length; i++) {
        // github.com/juju/juju/apiserver/params#AnnotationsGetResult
        result.results[i] = {};
        resp['results'][i] = resp['results'][i] || {};
        result.results[i].entity = resp['results'][i]['entity'];
        result.results[i].annotations = {};
        resp['results'][i]['annotations'] = resp['results'][i]['annotations'] || {};
        for (let k in resp['results'][i]['annotations']) {
          result.results[i].annotations[k] = resp['results'][i]['annotations'][k];
        }
        // github.com/juju/juju/apiserver/params#ErrorResult
        result.results[i].error = {};
        resp['results'][i]['error'] = resp['results'][i]['error'] || {};
        // github.com/juju/juju/apiserver/params#Error
        result.results[i].error.error = {};
        resp['results'][i]['error']['error'] = resp['results'][i]['error']['error'] || {};
        result.results[i].error.error.message = resp['results'][i]['error']['error']['message'];
        result.results[i].error.error.code = resp['results'][i]['error']['error']['code'];
      }
      callback(null, result);
    });
  }

  /**
    Set stores annotations for given entities

    @param {Object} args Arguments to be provided to Juju, as an object like
      the following:
        {
          annotations: []{
            entity: string,
            annotations: map[string]string
          }
        }
    @param {Function} callback Called when the response from Juju is available,
      the callback receives an error and the result. If there are no errors,
      the result is provided as an object like the following:
        {
          results: []{
            error: {
              message: string,
              code: string
            }
          }
        }
  */
  set(args, callback) {
    // Prepare request parameters.
    let params;
    // github.com/juju/juju/apiserver/params#AnnotationsSet
    params = {};
    args = args || {};
    params['annotations'] = [];
    args.annotations = args.annotations || [];
    for (let i = 0; i < args.annotations.length; i++) {
      // github.com/juju/juju/apiserver/params#EntityAnnotations
      params['annotations'][i] = {};
      args.annotations[i] = args.annotations[i] || {};
      params['annotations'][i]['entity'] = args.annotations[i].entity;
      params['annotations'][i]['annotations'] = {};
      args.annotations[i].annotations = args.annotations[i].annotations || {};
      for (let k in args.annotations[i].annotations) {
        params['annotations'][i]['annotations'][k] = args.annotations[i].annotations[k];
      }
    }
    // Prepare the request to the Juju API.
    const req = {
      type: 'Annotations',
      request: 'Set',
      version: 2,
      params: params
    };
    // Send the request to the server.
    this._transport.write(req, (err, resp) => {
      if (!callback) {
        return;
      }
      if (err) {
        callback(err, {});
        return;
      }
      // Handle the response.
      let result;
      // github.com/juju/juju/apiserver/params#ErrorResults
      result = {};
      resp = resp || {};
      result.results = [];
      resp['results'] = resp['results'] || [];
      for (let i = 0; i < resp['results'].length; i++) {
        // github.com/juju/juju/apiserver/params#ErrorResult
        result.results[i] = {};
        resp['results'][i] = resp['results'][i] || {};
        // github.com/juju/juju/apiserver/params#Error
        result.results[i].error = {};
        resp['results'][i]['error'] = resp['results'][i]['error'] || {};
        result.results[i].error.message = resp['results'][i]['error']['message'];
        result.results[i].error.code = resp['results'][i]['error']['code'];
      }
      callback(null, result);
    });
  }
}


const wrappers = require('../wrappers.js');
if (wrappers.wrapAnnotations) {
  // Decorate the facade class in order to improve user experience.
  AnnotationsV2 = wrappers.wrapAnnotations(AnnotationsV2);
}

module.exports = AnnotationsV2;
